# 첫 번째 시간

### 복사 생성자

> 객체(인스턴스)를 복사할 때 실행되는 함수!

> 클래스이름(const 클래스이름 &rhs);

```c
int a(10);   -> 생성
int b(a);    -> 복사 생성
```

생성자의 종류

1. 기본 생성자
2. 다중 정의된 생성자(매개변수O)
2-1. 변환 생성자(매개변수가 1개)
3. 복사 생성자
4. 이동 생성자


### 깊은 복사와 얕은 복사

> 깊은 복사는 복사에 의해 실제로 두 개의 값이 생성되는 것이고 얕은 복사는 대상이 되는 값은 여전히 하나뿐인데 접근 포인터만 둘로 늘어나는 것을 말한다.

**자세한 건 코드 참고하기**

# 두 번째 시간

### 대입 연산자

> C++에서는 연산자(+, -, *, /...)를 함수로 만들 수 있다.

```c
CMyData& operator=(const CMyData &rhs)
{
  *m_pnData = *rhs.m_pnData;
  
  //객체 자신에 대한 참조를 반환한다.
  return *this;
}
```

### 묵시적 변환

> 직접적으로는 아무런 언급이 없었지만 다들 잘 안다고 생각하지 때문에 생략하는 것

> 야, 이거 A로 바꾼다? => 야, 이거 바꾼다?

> 서로 사전에 교감하고 정보를 공유함으로써 지속적인 언급을 피할 수 있어서 생산성을 높일 수 있다. 하지만 오해가 발생할 수도 있다는 단점이 있다.

변환 생성자: 매개 변수가 하나인 생성자 + 반드시 앞에 explicit을 붙여줘야한다.(묵시적 변환 생성자가 사용자 모르게 호출될 가능성을 차단하기 위함)

```c
explicit CTest(int nParam)
{
  cout << "CTest(int)"" << endl;
  m_pData = new int(nParam);
}
```

# 세 번째 시간

### 임시 객체와 이동 시맨틱

```c
int a
a = 3 + 4;
```
위의 연산을 하는 데 필요한 int는 총 몇개일까? 3개?

4개이다.

왜냐하면 3과 4를 더해서 나온 7을 저장할 공간도 필요하기 때문이다. 이 때 7을 임시결과라고 부른다.

이 상황을 클래스와 객체에 대입하면 임시 객체라는 개념이 탄생한다.

3과 4를 더하는 것과 같은 단순한 계산이나 간단한 클래스에서는 굳이 임시 결과나 임시 객체에 대해 신경 쓸 필요가 없지만,

프로젝트의 규모가 커질 수록 메모리 관리와 효율이 중요해지기 때문에 반드시 임시 객체에 대해 사용해야한다.

# 네 번째 시간

임시 객체 때문에 이동 시맨틱과 r-value 참조라는 것이 생긴 것이다.

# 다섯 번째 시간

생성자 복습 -> 디폴트 생성자, 변환 생성자, 복사 생성자

### 이동 생성자

> r-value가 임시 객체인 순간 불리는 함수

> 갓호성 명언: 효율올리는 거 별거 아니다~! 안해도 되는 일을 안하면 돼.

```c
//이동 생성자
CMyData(const CMyData &&rhs); //r-value 참조
```

결론: 임시 객체의 덩어리가 클수록 이동 생성자는 빛을 발한다.
