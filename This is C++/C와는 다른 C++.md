# 첫 번째 시간

### 1. 절차지향 vs 객체지향

C언어는 절차지향이고 C++는 객체지향 언어이다.

절차지향은 절차를 지향하는 것이기에 스코프 안에 있는 코드들의 순서가 가장 중요하다.

> 그래서 개인의 능력이 C++보다 중요시 된다.
> 하지만 절차지향 프로그래밍 언어는 대규모의 프로그램을 만드는 데 있어서 조금 부족함이 있다.

객체지향은 서양철학에서 플라톤의 이데아론과 많이 닮아있다.

미인이라는 이데아가 있다면 현실에는 김태희, 설현 등등의 실체들이 있는 것처럼
객체지향은 설계와 구현이 분리되어 있다.

### 2. 글쓰기

프로그래밍은 글쓰기와 많이 닮아있다.
따라서 프로그래밍을 잘하고 싶다면 평소에 글을 많이 써라.

### 3. 내가 세탁을 하느냐 vs 세탁소에 내 옷을 맡기느냐

내가 세탁을 하는 것보다 세탁소에 내 옷을 맡기는 것이 더 전문성있고 옷도 더 잘 세탁될 것이다.

C와 C++도 마찬가지이다. 내가 세탁을 하는 것이 C라면 세탁소에 맡기는 것이 C++이다.

비용은 C++가 많이 들지만 효율이 좋다. 하지만 성능은 C가 좋다. (유지보수 측면에서)

printf()와 cout << 만 보더라도 printf()를 사용하려면 사용법(형식문자)를 알아야하지만 cout << 은 그냥 넣어주면 된다. 다르게 말한다면 C언어는 사용자가 물건을 알아서 잘 사용하라는 언어라면 C++는 물건을 잘 만들어서 사용자가 쉽게 사용할 수 있도록 하는 것이다.


# 두 번째 시간

```
int nData;
```

C에서는 nData를 변수라고 하지만 C++에서는 "nData는 int형식에 대한 인스턴스"라는 말을 더 많이 사용한다.

namespace => 소속

자료형: 일정 크기의 메모리에 저장된 정보를 해석하는 방법

```
// 선언 및 정의
int a = 10; //C언어 스타일
int b(10); //C++ 스타일
```

```
int a(10);
auto b(a); //b의 형식은 a을 따라간다.
```

auto 덕분에 형 의존적이지 않은 지네릭 프로그래밍이 가능하다 -> 대박이다. (이해X..)

# 세 번째 시간

C언어 메모리 동적 할당 / 해제

malloc() / free()

옛날에 생긴 문법인데 그 당시에 컴퓨터의 메모리가 적었던 것에 맞게 만들어진 문법이었다.

하지만 가상 메모리가 생기고 컴퓨터의 메모리가 증가하면서 malloc()이 실패하는 경우가 적어지면서 연산자로 바뀌었고

new 연산자가 나온 것이다.

new연산자의 특징

1. 메모리의 동적할당

2. class의 생성자를 호출

```
//C
int *pnData = (int*)malloc(sizeof(int) * 5);
free (pnData);
//C++
int *pnNewData = new int[5];
delete [] pnNewData;
```

**참조자 형식**
```
int nData(10);
cout << nData << endl; // 10출력
//참조자는 '별명'이다.
int &rData = nData;

rData = 5;
cout << nData << endl; // 5출력
//nData의 주소와 rData의 주소가 같다.
cout << &nData << endl; 
cout << &rData << endl;
```

참조자를 사용하는 이유? => 포인터의 문제점(변절이다!)

포인터는 변수이기에 변할 수 있다

참조자는 변하지 않는 포인터이다!

# 네 번째 시간

r-value 참조 <- 왜 생겼지?

임시객체가 성능을 저하시킬 수 있는데

그걸 피하기 위해 '이름이 없는' 임시객체를 처리하기 위해 존재한다. => 나중에 자세히 설명

```
int &&rData = 3;
```

범위 기반 for문

```c
#include <iostream>
using namespace std;
int main(void)
{
  int aList[5] = {40, 30, 20, 10, 50};

  for (int i=0; i<5; i++)
    printf("%d ", aList[i]);

  for (auto n : aList)  // 알아서 모든 내용을 출력해준다. 배열의 크기가 달라져도 신경쓰지 않아도 된다. +배열의 형식에 따라 n의 형식이 결정된다.
    printf("%d ", n);
  return 0;
}
```
