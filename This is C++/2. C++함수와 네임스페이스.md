# 첫 번째 시간

### 디폴트 매개변수

```c
void TestFunc(int a, int b = 10);  //디폴트 매개변수는 원형에서 선언해야한다.

int main(void)
{
  TestFunc(3); // 3 10 출력
  TestFunc(4); // 3 4 출력
  return 0;
}

void TestFunc(int a, int b) //디폴트 매개변수는 원형에서 선언해야한다.
{
  printf("a: %d, b: %d\n", a, b);
}
```

하지만 디폴트 매개변수는 가급적 사용하지 마라 (함수의 원형을 알 수 없다 => 모호성 => 유지보수가 힘들어 진다.)
 
# 두 번째 시간
 
### 힘수 다중 정의

이름이 같은 함수가 여러 개 있는 것

```c
int Add(int a, int b)
{
  return a + b;
}

double Add(double a, double b)
{
  return a + b;
}

int main(void)
{
  cout << Add(3,4) << endl;
  cout << Add(3.3, 4.4) << endl;
  return 0;
}
```

### 함수 템플릿

함수 다중 정의보다는 함수 템플릿을 더 많이 사용한다.

```c
template <typename T>
T Add(T a, T b)
{
  return a + b;
}

int main(void)
{
  cout << Add(3,4) << endl;
  cout << Add(3.3, 4.4) << endl;
  return 0;
}
```

템플릿에는 함수 템플릿과 클래스 템플릿이 있다.

# 세 번째 시간

### 인라인 함수

### 네임 스페이스

왜 쓰는가? 사람이 변수나 함수명을 선언 할 때 거기서 거기 => 같은 변수명과 함수명이 생길 수 있다. => 소속(namespace)를 정해준다.

```c
#include <iostream>
using namespace std;

namespace TEST
{
  int g_nData = 100;
  namespace DEV
  {
    int g_nData = 200;
    namespace WIN;
    {
      int g_nData = 300;
    }
  }
}

int main(void)
{
  cout << TEST::g_nData << endl; //100
  cout << TEST::DEV::g_nData << endl; //200
  cout << TEST::DEV::WIN::g_nData << endl; //300
  
  return 0;
}
```
